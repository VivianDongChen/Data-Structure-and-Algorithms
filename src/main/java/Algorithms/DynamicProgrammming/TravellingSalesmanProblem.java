package Algorithms.DynamicProgrammming;

import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * 旅行商问题 - 动态规划
 */
public class TravellingSalesmanProblem {

    /*
        北京->
        上海->
        武汉->
        西安->

        4x3x2 = 24
        5x4x3x2 = 120
        ...
        (n-1)!
        北京->上海->
                  武汉->西安->北京
                  西安->武汉->北京
             西安->
                  上海->武汉->北京
                  武汉->上海->北京
             武汉->
                  上海->西安->北京
                  西安->上海->北京
         ----------------------------------------------------------------------------------
         g
              0  1  2  3
          0  {0, 1, 2, 3}
          1  {1, 0, 6, 4}
          2  {2, 6, 0, 5}
          3  {3, 4, 5, 0}

          d(出发城市, 剩余城市集合) ==> 从出发城市开始，走完剩余城市，花费的最少代价

          d(0,1|2|3) => g[0][1] + d(1,2|3)
                                      =>  g[1][3] + d(3,2)
                                                      => g[3][2] + d(2,空)
                                                                       =>  g[2][0]
                                      =>  g[1][2] + d(2,3)
                                                      => g[2][3] + d(3,空)
                                                                       =>  g[3][0]
                    =>  g[0][2] + d(2,1|3)
                                      => g[2][1] + d(1,3)
                                                      => g[1][3] + d(3,空)
                                                                       =>  g[3][0]
                                      => g[2][3] + d(3,1)
                                                      => g[3][1] + d(1,空)
                                                                       =>  g[1][0]
                    =>  g[0][3] + d(3,1|2)
                                      => g[3][1] + d(1,2)
                                                      => g[1][2] + d(2,空)
                                                                       =>  g[2][0]
                                      => g[3][2] + d(2,1)
                                                      => g[2][1] + d(1,空)
                                                                       =>  g[1][0]
          规律：

          出发城市 i
          剩余城市集合 j
            遍历 j 时的变量 k （剩余的某一个城市)
          d(i, j) => min(
                        g[i][k] + d(k, j去掉k)
                        g[i][k] + d(k, j去掉k)
                        g[i][k] + d(k, j去掉k)
                    )
          d(k,空) => 从k回到起点 => g[k][i]


           dp数组：

                0   1   2   3    4   5    6    7     j 剩余城市（索引）的集合
                0   1   2   1|2  3   1|3  2|3  1|2|3
           0
           1
           2
           3
       i 出发城市（索引）

          用一个二进制数来表示剩余城市的集合：
           000 没城市  0   二进制为0表示没有城市
           001 1号    1   二进制第一位表示1号城市
           010 2号    2   二进制第二位表示2号城市
           100 3号    4   二进制第三位表示3号城市
           011 1和2   3   二进制各位组合表示3个城市的组合
           101 1和3   5
           110 2和3   6
           111 1和2和3 7


          d(0,1|2) => g[0][1] + d(1,2)
                   => g[0][2] + d(2,1)
          d(1,1|2)
          d(2,1|2)
          d(3,1|2) => g[3][1] + d(1,2)
                   => g[3][2] + d(2,1)
     */

    public static void main(String[] args) {
        int[][] graph = {
                {0, 1, 2, 3},
                {1, 0, 6, 4},
                {2, 6, 0, 5},
                {3, 4, 5, 0},
        };
        System.out.println(tsp(graph));
    }
    static int tsp(int[][] g) {
        //初始化dp二维数组
        int m = g.length; //行是城市数目
        int n = 1 << (m - 1); //列是剩余城市的组合数，即 2^（m-1）
        int[][] dp = new int[m][n];

        //填充第0列
        for (int k = 0; k < m; k++) {
            dp[k][0] = g[k][0];
        }
        print(dp);


        //填充后序列
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < m; i++) {
                dp[i][j] = Integer.MAX_VALUE / 2;   //初始值赋值为一个较大的值（因为后面要求min）， 但是这个值参与计算容易变成负数，所以除以2
                if(contains(j,i)){     //剩余城市集合不可能包含出发城市， 如果不包含，才需要进行进一步的填充
                    continue;
                }
                //填充单元格
                for (int k = 0; k < m; k++) {    //这里遍历每一个城市，用排除法查看这个城市是否在集合中
                    if(contains(j,k)){
                        dp[i][j] = Math.min(dp[i][j], g[i][k] + dp[k][exclude(j,k)]);
                    }
                }
            }
        }
        print(dp);
        return dp[0][n-1];
    }

    /**
     * 打印二维数组
     * @param dist 二维数组
     */
    static void print(int[][] dist) {
        System.out.println("-------------------------");
        for (int[] row : dist) {
            System.out.println(Arrays.stream(row).boxed()
                    .map(x -> x >= Integer.MAX_VALUE / 2 ? "∞" : String.valueOf(x))
                    .map(s -> String.format("%2s", s))
                    .collect(Collectors.joining(",", "[", "]")));
        }
    }




    /**
     * 检查城市是否包含在二进制集合中
     * @param set 二进制数（表示城市索引的集合）
     * @param city 城市索引
     * @return 是否包含该城市
     */
    static boolean contains(int set, int city) {

        /*
        110 （表示2|3）

        110  城市1是否存在    110      右移（1-1）= 0位，获得原二进制的第1位
                           001 &     按位于1获得二进制第1位的值
                           ----
                           000
                           false
        110  城市2是否存在    011      右移（2-1）= 1位，获得原二进制的第2位
                           001 &
                           ----
                           001
                           true
        110  城市3是否存在    001      右移（3-1）= 2位，获得原二进制的第3位
                           001 &
                           ----
                           001
                           true

        二进制按位与运算规律：
            1 & 1 = 1
            1 & 0 = 0
            0 & 1 = 0
            0 & 0 = 0

        任何数与0按位于结果为0
        任何数与1按位于结果为其本身

     */
        return (set >> (city - 1) & 1) == 1;
    }


    /**
     * 从二进制集合中排除某个城市
     * @param set 二进制数（表示城市索引的集合）
     * @param city 城市索引
     * @return 排除操作之后的二进制集合
     */
    static int exclude(int set, int city) {

        /*
        111（表示1|2|3）  排除1 => 110 （表示2|3）

        111
        001 ^  异或   001（表示城市1）  1左移（1-1）位 = 001
        ----
        110     2|3


        111 （表示1|2|3）  排除2 => 101 （表示1|3）

        111
        010 ^  异或    010（表示城市2）  1左移（2-1）位 = 010
        ----
        101   1|3

        二进制的异或运算规则：

        0 ^ 0 = 0
        1 ^ 1 = 0
        0 ^ 1 = 1
        1 ^ 0 = 1

        任何数与0异或结果为其本身
        任何数与1异或结果为该数的反转

     */
        return set ^ (1 << (city - 1));
    }

}
